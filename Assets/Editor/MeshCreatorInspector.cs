using UnityEditor;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

/***
* MeshCreatorInspector
*	modifies the inspector to show controls for the Mesh Creator.
*	this script needs to be in the Editor folder of your project along
*	with the SimpleSurfaceEdge.cs and the Triangulator.cs script.
***/
[CustomEditor(typeof(MeshCreatorData))]
public class MeshCreatorInspector :  Editor {
	
	private MeshCreatorData mcd;
	
	/***
	* OnEnable
	* 	set the MeshCreator when component is added to the object
	***/
	private void OnEnable()
    {
		mcd = target as MeshCreatorData;
		if (mcd == null) {
			Debug.LogError("MeshCreatorInspector::OnEnable(): couldn't find a MeshCreatorData component");
		}
    }
	
	/***
	* OnInspectorGUI
	*	this does the main display of information in the inspector.
	***/
	public override void OnInspectorGUI() {
		EditorGUIUtility.LookLikeInspector();
		//EditorGUIUtility.LookLikeControls();
		
		// TODO: inspector layout should be redesigned so that it's easier to 
		//	 see the texture and material information
		if (mcd != null) {
			EditorGUILayout.LabelField("Mesh Creation Outline", "");
			mcd.outlineTexture = EditorGUILayout.ObjectField("Mesh Outline Texture", mcd.outlineTexture, typeof(Texture2D)) as Texture2D;
			mcd.uvWrapMesh = EditorGUILayout.Toggle("Use UV mapped mesh", mcd.uvWrapMesh);
			// this is for future support of poster graphics and mesh extrusion
			if (!mcd.uvWrapMesh) {
				mcd.createEdges = EditorGUILayout.Toggle("Use UV mapped edge", mcd.createEdges);
				mcd.createBacksidePlane = EditorGUILayout.Toggle("Use backside plane", mcd.createBacksidePlane);
			}
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Material Assignment", "");
			mcd.useAutoGeneratedMaterial = EditorGUILayout.Toggle("Use Generated Material", mcd.useAutoGeneratedMaterial);
			if (!mcd.useAutoGeneratedMaterial) mcd.frontMaterial = EditorGUILayout.ObjectField("Mesh Material", mcd.frontMaterial, typeof(Material)) as Material;
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Physics Material", "");
			mcd.usePhysicMaterial = EditorGUILayout.Toggle("Use Physics Material", mcd.usePhysicMaterial);
			if (mcd.usePhysicMaterial) mcd.physicMaterial = EditorGUILayout.ObjectField("Physical Material", mcd.physicMaterial, typeof(PhysicMaterial)) as PhysicMaterial;
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Size and Placement", "");
			mcd.meshHeight = EditorGUILayout.FloatField("Mesh Height", mcd.meshHeight);
			mcd.meshWidth = EditorGUILayout.FloatField("Mesh Width", mcd.meshWidth);
			mcd.meshDepth = EditorGUILayout.FloatField("Mesh Depth", mcd.meshDepth);
			
			mcd.heightOffset = EditorGUILayout.FloatField("Height Offset", mcd.heightOffset);
			mcd.widthOffset = EditorGUILayout.FloatField("Width Offset", mcd.widthOffset);
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Collider Generation", "");
			mcd.generateCollider = EditorGUILayout.Toggle("Generate Collider", mcd.generateCollider);
			if (mcd.generateCollider) mcd.usePrimitiveCollider = EditorGUILayout.Toggle("Use Primitive Collider", mcd.usePrimitiveCollider);
			if (mcd.usePrimitiveCollider) mcd.smallestBoxArea = EditorGUILayout.FloatField("Smallest Box Area", mcd.smallestBoxArea);
			EditorGUILayout.Space();
			
			if (GUILayout.Button("Update Mesh", GUILayout.MaxWidth(100))) {
				// do some simple parameter checking here so we don't get into trouble
				if (mcd.smallestBoxArea < 2) {
					Debug.LogWarning("Mesh Creator: smallest box area should be larger than 1.");
				}
				else {
					UpdateMesh();
					//Editor.Repaint(); // error when deleting colliders
				}
			}
		}
		else {
			Debug.LogError("MeshCreatorInspector::OnInspectorGUI(): couldn't find a MeshCreatorData component");
		}
		
	}
	
	// this corresponds with the Update Mesh button
    void UpdateMesh () {
			// unity should prevent this from happening to the inspector, but just in case.....
			if (mcd == null) {
				Debug.LogError("MeshCreatorInspector Error: selected object does not have a MeshCreatorData component. Select an object with a MeshCreatorData component to update."); // TODO: add instructions on how to fix
				return;
			}
			
			// add a TextureImporter object here to check whether texture is readable
			// set it to readable if necessary
			if (mcd.outlineTexture == null) {
				Debug.LogError("MeshCreatorInspector Error: no texture found. Make sure to have a texture selected before updating mesh.");
				return;
			}
			
			// stash the rotation value, set back to identity, then switch back later
			Quaternion oldRotation = mcd.gameObject.transform.rotation;
			mcd.gameObject.transform.rotation = Quaternion.identity;
				
			// stash the scale value, set back to one, then switch back later
			Vector3 oldScale = mcd.gameObject.transform.localScale;
			mcd.gameObject.transform.localScale = Vector3.one;
			
			Mesh msh = new Mesh();
			Mesh collidermesh = new Mesh();
			if (mcd.uvWrapMesh) {
				// Set up game object with mesh;
				AssignMesh(ref msh);
				collidermesh = msh;
			}
			else {
				AssignPlaneMesh(ref msh);
				AssignMesh(ref collidermesh);
			}
			
			MeshRenderer mr = (MeshRenderer) mcd.gameObject.GetComponent("MeshRenderer");
			if (mr == null) {
				Debug.Log("MeshCreator Warning: no mesh renderer found on update object, adding one.");
				mcd.gameObject.AddComponent(typeof(MeshRenderer));
			}
			
			// update the front material via renderer
			// TODO: cleanup the redundant code below
			Material meshmat;
			if (mcd.useAutoGeneratedMaterial) {
				// if using uvWrapMesh, use regular material
				if (mcd.uvWrapMesh) {
					meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
					if (meshmat == null) {
						AssetDatabase.CopyAsset("Assets/Materials/baseMaterial.mat", "Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
						AssetDatabase.ImportAsset("Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
						meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
						meshmat.name = mcd.outlineTexture.name + ".Material";
						meshmat.mainTexture = mcd.outlineTexture;
						AssetDatabase.SaveAssets();
					}
					else {
						Debug.LogWarning("Mesh Creator: found existing material. If you want a new one created, delete Assets/Materials/" + mcd.outlineTexture.name +".material.mat");
					}
					mcd.gameObject.renderer.sharedMaterial = meshmat;
				}
				else { // use a transparent material
					meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
					if (meshmat == null) {
						AssetDatabase.CopyAsset("Assets/Materials/baseTransparentMaterial.mat", "Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
						AssetDatabase.ImportAsset("Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
						meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
						meshmat.name = mcd.outlineTexture.name + ".Material";
						meshmat.mainTexture = mcd.outlineTexture;
						AssetDatabase.SaveAssets();
					}
					else {
						Debug.LogWarning("Mesh Creator: found existing material. If you want a new one created, delete Assets/Materials/" + mcd.outlineTexture.name +".material.mat");
					}
					mcd.gameObject.renderer.sharedMaterial = meshmat;
				}
			}
			else {
				mcd.gameObject.renderer.sharedMaterial = mcd.frontMaterial;
			}
			
			MeshFilter mf = (MeshFilter) mcd.gameObject.GetComponent("MeshFilter");
			if (mf == null) {
				Debug.LogWarning("MeshCreator Warning: no mesh filter found on update object, adding one.");
				mf= mcd.gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
			}
			DestroyImmediate(mf.sharedMesh);  // get rid of the old shared mesh
			mf.sharedMesh = msh;
			
			// if we need the side edges, go ahead and make a new game object for that
			if (!mcd.uvWrapMesh && mcd.createEdges) {
				Mesh edgemesh = new Mesh();
				AssignEdgeMesh(ref edgemesh);
				
				// remove the old backside mesh game object
				string edgeName = mcd.gameObject.name + ".edge";
				ArrayList destroyObject = new ArrayList();
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == edgeName) {
						destroyObject.Add(child);
					}
				}
				
				while (destroyObject.Count > 0) {
					Transform child = (Transform) destroyObject[0];
					destroyObject.Remove(child);
					DestroyImmediate(child.gameObject);
				}
				
				// create a new game object to attach the backside plane
				GameObject edgeObject = new GameObject();
				edgeObject.transform.parent = mcd.gameObject.transform;
				edgeObject.transform.localPosition = Vector3.zero;
				edgeObject.transform.rotation = Quaternion.identity;
				edgeObject.name = edgeName;
				MeshFilter edgemf = (MeshFilter) edgeObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
				edgemf.sharedMesh = edgemesh;
				
				MeshRenderer edgemr = edgeObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
				edgemr.renderer.sharedMaterial = mcd.gameObject.renderer.sharedMaterial;
			}
			else {
				string edgeName = mcd.gameObject.name + ".edge";
				ArrayList destroyObject = new ArrayList();
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == edgeName) {
						destroyObject.Add(child);
					}
				}
				while (destroyObject.Count > 0) {
					Transform child = (Transform) destroyObject[0];
					destroyObject.Remove(child);
					DestroyImmediate(child.gameObject);
				}
			}
			
			if (!mcd.uvWrapMesh && mcd.createBacksidePlane) {
				Mesh backmesh = new Mesh();
				AssignPlaneMeshBackside(ref backmesh);
				
				// remove the old backside mesh game object
				string backsideName = mcd.gameObject.name + ".backside";
				ArrayList destroyObject = new ArrayList();
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == backsideName) {
						destroyObject.Add(child);
					}
				}
				
				while (destroyObject.Count > 0) {
					Transform child = (Transform) destroyObject[0];
					destroyObject.Remove(child);
					DestroyImmediate(child.gameObject);
				}
				
				// create a new game object to attach the backside plane
				GameObject backsideObject = new GameObject();
				backsideObject.transform.parent = mcd.gameObject.transform;
				backsideObject.transform.localPosition = Vector3.zero;
				backsideObject.transform.rotation = Quaternion.identity;
				backsideObject.name = backsideName;
				MeshFilter backmf = (MeshFilter) backsideObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
				backmf.sharedMesh = backmesh;
				
				MeshRenderer backmr = backsideObject.AddComponent(typeof(MeshRenderer)) as MeshRenderer;
				backmr.renderer.sharedMaterial = mcd.gameObject.renderer.sharedMaterial;
			}
			else {
				// remove the old backside mesh game object
				string backsideName = mcd.gameObject.name + ".backside";
				ArrayList destroyObject = new ArrayList();
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == backsideName) {
						destroyObject.Add(child);
					}
				}
				
				while (destroyObject.Count > 0) {
					Transform child = (Transform) destroyObject[0];
					destroyObject.Remove(child);
					DestroyImmediate(child.gameObject);
				}
			}
			
			// generate a mesh collider
			if (mcd.generateCollider && !mcd.usePrimitiveCollider) {
				Collider col = mcd.gameObject.collider;
				if (col == null) {
					mcd.gameObject.AddComponent(typeof(MeshCollider));
				}
				// remove the old compound collider if necessary
				string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
				foreach(Transform child in mcd.gameObject.transform) {
					if (child.name == compoundColliderName) {
						DestroyImmediate(child.gameObject);
					}
				}
				
				//~ // stash the rotation value, set back to identity, then switch back later
				//~ Quaternion oldRotation = mcd.gameObject.transform.rotation;
				//~ mcd.gameObject.transform.rotation = Quaternion.identity;
				
				//~ // stash the scale value, set back to one, then switch back later
				//~ Vector3 oldScale = mcd.gameObject.transform.localScale;
				//~ mcd.gameObject.transform.localScale = Vector3.one;
				
				MeshCollider mcol = mcd.gameObject.GetComponent("MeshCollider") as MeshCollider;
				if (mcol == null) {
					Debug.LogWarning("MeshCreator Warning: found a non-Mesh collider on object to update. If you really want a new collider generated, remove the old one and update the object with MeshCreator again.");
				}
				else {
					mcol.sharedMesh = collidermesh;
				}
				if (mcd.usePhysicMaterial) {
					mcol.material = mcd.physicMaterial;
				}
				//~ mcd.gameObject.transform.rotation = oldRotation;
				//~ mcd.gameObject.transform.localScale = oldScale;
			}
			else if (mcd.generateCollider && mcd.usePrimitiveCollider) {
				// remove the old collider if necessary
				Collider col = mcd.gameObject.collider;
				if (col != null) { 
					//DestroyImmediate(col); // using destroy here causes a editor error after the script runs
					//DestroyImmediate(col.sharedMesh);
					Debug.LogWarning("Mesh Creator: found a collider on game object " + name +", please remove it.");
					MeshCollider mshcol = mcd.gameObject.GetComponent("MeshCollider") as MeshCollider;
					if (mshcol != null) {
						Debug.LogWarning("Mesh Creator: found a mesh collider on game object " + name + ", destroying it's mesh.");
						//DestroyImmediate(mshcol.sharedMesh);
						mshcol.sharedMesh = null;
					}
				}
				
				// all compound colliders are stored in a gameObject 
				string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
				GameObject go = new GameObject();
				// find old compound colliders and remove
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == compoundColliderName) {
						DestroyImmediate(go);
						go = child.gameObject;
						ArrayList removeChildren = new ArrayList();
						foreach (Transform childchild in child) {
							removeChildren.Add(childchild);
						}
						foreach (Transform childchild in removeChildren) {
							DestroyImmediate(childchild.gameObject);
						}
					}
				}
				
				//~ // stash the rotation value, set back to identity, then switch back later
				//~ Quaternion oldRotation = mcd.gameObject.transform.rotation;
				//~ mcd.gameObject.transform.rotation = Quaternion.identity;
				
				//~ // stash the scale value, set back to one, then switch back later
				//~ Vector3 oldScale = mcd.gameObject.transform.localScale;
				//~ mcd.gameObject.transform.localScale = Vector3.one;
				
				go.name = compoundColliderName;
				go.transform.parent = mcd.gameObject.transform;
				go.transform.localPosition = Vector3.zero;
				go.transform.rotation = Quaternion.identity;
				ArrayList boxColliderCoordinates = GetBoxColliderCoordinates();
				int count = 0;
				int imageHeight = mcd.outlineTexture.height;
				int imageWidth = mcd.outlineTexture.width;
				foreach (Vector4 bcc in boxColliderCoordinates) {
					Vector4 bc = bcc;
					// if using a uvWrapMesh, subtract half a pixel from each side 
					if (mcd.uvWrapMesh && Math.Abs(bc.x - bc.z) > 1.0f && Math.Abs(bc.y - bc.w) > 1.0f) {
						bc.x += 0.5f;
						bc.y += 0.5f;
						bc.z -= 0.5f;
						bc.w -= 0.5f;
					}
					else if (mcd.uvWrapMesh) { // if here, height or width is only one
						continue;
					}
					count++;
					GameObject colgo = new GameObject();
					colgo.name = compoundColliderName+"."+count;
					colgo.transform.parent = go.transform;
					colgo.transform.localPosition = Vector3.zero;
					BoxCollider bxcol = colgo.AddComponent(typeof(BoxCollider)) as BoxCollider;
					
					float vertX = 1.0f - (bc.x/imageWidth) ; // get X point and normalize
					float vertY = bc.y/imageHeight ; // get Y point and normalize
					float vert2X = 1.0f - (bc.z/imageWidth);
					float vert2Y = bc.w/imageHeight;
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					
					vert2X = (vert2X * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vert2Y = (vert2Y * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vert2X = vert2X + mcd.widthOffset;
					vert2Y = vert2Y + mcd.heightOffset;
					
					bxcol.center = new Vector3(vertX - ((vertX-vert2X)/2.0f), vertY - ((vertY-vert2Y)/2.0f), 0.0f);
					bxcol.size = new Vector3(Math.Abs(vertX-vert2X), Math.Abs(vertY-vert2Y), mcd.meshDepth);
					if (mcd.usePhysicMaterial) {
						bxcol.material = mcd.physicMaterial;
					}
				}
				//~ mcd.gameObject.transform.rotation = oldRotation;
				//~ mcd.gameObject.transform.localScale = oldScale;
			}
			mcd.gameObject.transform.rotation = oldRotation;
			mcd.gameObject.transform.localScale = oldScale;
    }  
	
	// TODO: this should be moved to another script, kinda funky here
	ArrayList GetBoxColliderCoordinates() {
		ArrayList boxCoordinates = new ArrayList();
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);

		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// possibly do some size checking
		// TODO: check for a square power of two
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
		}
		
		// copy the pixels so they can be modified
		Color[] pix = new Color[pixels.Length];
		for (int i = 0; i < pixels.Length; i++) {
			Color pixel = pixels[i];
			pix[i] = new Color(pixel.r, pixel.g, pixel.b, pixel.a);
		}
		
		Vector4 boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		while ((Math.Abs(boxCoord.x-boxCoord.z) * Math.Abs(boxCoord.y-boxCoord.w) ) >= mcd.smallestBoxArea) {
			//Debug.Log("Largest Box " + boxCoord);
			boxCoordinates.Add(boxCoord);
			boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		}
		//Debug.Log("Last box was " + boxCoord);
		return boxCoordinates;
	}
	
	/***
	* int n, m ; 
	Cin  >> n >> m ;
	Vector < Vector < int >  > a ( n, Vector < int >  ( m ) ) ; 
	for  ( int I = 0 ; I < n ;  + + I ) 
		for  ( int j = 0 ; j < m ;  + + j ) 
			??Cin  >> a [ I ] [ j ] ; 
	 
	int ans =  0 ;
	Vector < int > d ( m, - 1 ) , d1 ( m ) , D2 ( m ) ;
	stack < int > ST ; 
	for  ( int I = 0 ; I < n ;  + + I )  { 
		for  ( int j = 0 ; j < m ;  + + j ) 
			??if  ( a [ I ] [ j ]  == 1 )
				d [ j ]  = I ; 
		while  ( ! ST. empty ( ) ) ST. pop ( ) ; 
		for  ( int j = 0 ; j < m ;  + + j )  ??{ 
			while  ( ! ST. empty ( )  & & d [ ST. top ( ) ]  <= d [ j ] )  ST. pop ( ) ;
			d1 [ j ]  = ST. empty ( )  ?  - 1 : ST. top ( ) ;
			ST. push  ( j ) ; 
		} 
		while  ( ! ST. empty ( ) ) ST. pop ( ) ; 
		for  ( int j = m - 1 ; j > = 0 ;  - j )  { 
			while  ( ! ST. empty ( )  & & d [ ST. top ( ) ]  <= d [ j ] )  ST. pop ( ) ;
			D2 [ j ]  = ST. empty ( )  ? m : ST. top ( ) ;
			ST. push  ( j ) ; 
		} 
		for  ( int j = 0 ; j < m ;  + + j )
			??ans = max ( ans, ( I - d [ j ] )  *  ( D2 [ j ]  - d1 [ j ]  - 1 ) ) ; 
	} 
	 
	cout  << ans ;
http://e-maxx.ru/algo/maximum_zero_submatrix
***/
Vector4 GetLargestBox(ref Color[] pixs, int imageWidth, int imageHeight) {
	Vector4 largestBox = new Vector4(-1.0f,-1.0f,-1.0f,-1.0f);
	int n = imageHeight;
	int m = imageWidth; 
	//List<int> olist = new List<int>(m);
	List< List<int> > a = new List< List<int> > ( n ) ;
	for (int i = 0; i < n; i++) {
		a.Add(new List<int>(m));
		for (int j = 0; j < m; j++) {
			a[i].Add(0);
		}
	}
	//Debug.Log("a has " + a.Count);
	for  ( int I = 0 ; I < n ; I++ ) {
		for  ( int j = 0 ; j < m ;  j++ ) {
			if (pixs[j + (imageWidth * I )].a != 1.0f) a[ I ][ j ] = 1; // is this right?
			//else a[ I ][ j ] = 0;
		}
	}
	 
	int ans =  0 ;
	List < int > d  = new List < int > ( m );
	List < int > d1 = new List <int> ( m );
	List <int >  d2 = new List<int>( m ) ;
	for (int i = 0; i < m; ++i) {
		d.Add(-1);
		d1.Add(-1);
		d2.Add(-1);
	}
	
	Stack < int > st = new Stack<int>(); 
	for (int i=0; i<n; ++i) {
		for (int j=0; j<m; ++j) if (a[i][j] == 1) d[j] = i;
		while (st.Count > 0) st.Pop(); // empty the stack
		for (int j=0; j<m; ++j) {
			while (st.Count > 0 && d[st.Peek()] <= d[j])  st.Pop();
			d1[j] = st.Count == 0 ? -1 : st.Peek();
			st.Push(j);
		}
		while (st.Count > 0) st.Pop();
		for (int j=m-1; j>=0; --j) {
			while (st.Count>0 && d[st.Peek()] <= d[j])  st.Pop();
			d2[j] = st.Count == 0 ? m : st.Peek();
			st.Push (j);
		}
		for (int j=0; j<m; ++j) {
			int oldLarge = ans;
			ans = Math.Max (ans, (i - d[j]) * (d2[j] - d1[j] - 1));
			if (oldLarge != ans) {
				largestBox[2] = d2[j];//correct
				largestBox[3] = i+1; // correct
				largestBox[0] = d1[j] +1;//(d2[j] - d1[j] - 1);
				largestBox[1] = d[j]+1;
			}
		}
	} 
	
	// remove inside pixels from the box area
		if (largestBox.x != -1.0f) {
			for (int i = (int)largestBox.x ; i < (int)largestBox.z; i++) {
				for (int j = (int)largestBox.y ; j < (int)largestBox.w; j++) {
					pixs[i + (j *imageWidth)].a = 0.0f;
				}
			}
			// delete all pixels if this is width 1 or height 1
			if ( ((int)Math.Abs(largestBox.x-largestBox.z) == 1) || ((int)Math.Abs(largestBox.y-largestBox.w) == 1) ){
				for (int i = (int)largestBox.x; i <= (int)largestBox.z; i++) {
					for (int j = (int)largestBox.y; j <= (int)largestBox.w; j++) {
						pixs[i + (j *imageWidth)].a = 0.0f;
					}
				}
			}
		}
		else {
			Debug.Log("got negative box");
		}
	
	return largestBox;
}
	
	/***
	* GetLargestBoxOld
	*	takes pixel data ref and finds largest rectangular area of solid opaque pixels.
	*	pixels are then deleted inside that rectangular area.
	* returns Vector4 of opposite corner coordinates, or Vector4(-1.0) if no area found.
	*
	* TODO: this is really slow. incrementally checking pixel box areas is not efficient. 
	*	maybe try checking max first and then half that amount, then half, and so on.
	*    check this: http://stackoverflow.com/questions/1726632/dynamic-programming-largest-square-block
	*
	* this should be removed....it's bad code.
	***/
	Vector4 GetLargestBoxOld(ref Color[] pixs, int imageWidth, int imageHeight) {
		Vector4 boxCoords = new Vector4(-1.0f, -1.0f, -1.0f, -1.0f);
		int area = 1; // smallest possible area
		
		// determine largest box area
		for (int x = 0; x < imageWidth; x++) {
			for (int y = 0; y < imageHeight; y++) {
				// get the first pixel
				float pixelAlpha = pixs[x + (imageWidth * y)].a;
				
				// only continue if the current pixel is opaque
				if (pixelAlpha != 1.0) continue;
				
				// determine largest opaque square
				for (int i = 1; i < imageWidth - x; i++) {
					for (int j = 1; j < imageHeight - y; j++) {
						if ( (i*j) > area) {
							if (IsOpaque(ref pixs, x, y, i, j, imageWidth, imageHeight)) {
								if ((i*j) > area) {
									boxCoords = new Vector4(x,y,x+i,y+j);
									area = i*j;
								}
							}
							else {
								break;
							}
						}
					}
				}
			}
		}
		
		// remove inside pixels from the box area
		if (boxCoords.x != -1.0f) {
			for (int i = (int)boxCoords.x + 1; i < (int)boxCoords.z; i++) {
				for (int j = (int)boxCoords.y + 1; j < (int)boxCoords.w; j++) {
					pixs[i + (j *imageWidth)].a = 0.0f;
				}
			}
			// delete all pixels if this is width 1 or height 1
			if ( ((int)Math.Abs(boxCoords.x-boxCoords.z) == 1) || ((int)Math.Abs(boxCoords.y-boxCoords.w) == 1) ){
				for (int i = (int)boxCoords.x; i <= (int)boxCoords.z; i++) {
					for (int j = (int)boxCoords.y; j <= (int)boxCoords.w; j++) {
						pixs[i + (j *imageWidth)].a = 0.0f;
					}
				}
			}
		}
		return boxCoords;
	}
	
	/***
	* IsOpaque
	*	determines if all all pixels in a box of the given parameters are opaque.
	* remove this
	***/
	bool IsOpaque(ref Color[] pixs, int startx, int starty, int width, int height, int imageWidth, int imageHeight) {
		if ((startx + width) > imageWidth) return false;
		if ((starty + height) > imageHeight) return false;
		for (int x = startx; x <= startx+width; x++) {
			for (int y = starty; y <= starty + height; y++) {
				float alpha = pixs[x+(imageWidth *y)].a;
				if (alpha != 1.0) return false;
			}
		}
		return true;
	}
	
	/*
	*	GetMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignMesh(ref Mesh msh) {
			string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
			TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
			textureImporter.isReadable = true;
			AssetDatabase.ImportAsset(path);
			
			//Debug.Log("found texture " + outlineTexture.width + "," + outlineTexture.height);
			Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			//Debug.Log("total pixel count " + pixels.Length);
			
			// possibly do some size checking
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
				Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
				Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
			}
			
			// make a surface object to create and store data from image
			MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			// Create the mesh
			//Mesh msh = new Mesh();
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				Triangulator tr = new Triangulator(vertices2D);
				int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 4];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 4];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = -mcd.meshDepth/2.0f;
				float halfVerticalPixel = 0.5f/imageHeight;
				float halfHorizontalPixel = 0.5f/imageWidth;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					vertices[i] = new Vector3(vertX, vertY, -halfDepth);
					vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
					vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
					vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
					uvs[i+(vertices2D.Length*2)] = uvs[i];
					uvs[i+(vertices2D.Length*3)] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
				// copy over the front and back index data
				for (int i = 0; i < indices.Length; i++) {
					allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
					allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
				}
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
					allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
					allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
					allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
				allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					// TODO: this needs to check if the current list is inside another shape
					// Use the triangulator to get indices for creating triangles
					Triangulator tr = new Triangulator(vertices2D);
					int[] indices = tr.Triangulate(); // these will be reversed for the back side
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = -mcd.meshDepth/2.0f;
					float halfVerticalPixel = 0.5f/imageHeight;
					float halfHorizontalPixel = 0.5f/imageWidth;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX, vertY, -halfDepth);
						vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
						vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
						vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
						uvs[i+(vertices2D.Length*2)] = uvs[i];
						uvs[i+(vertices2D.Length*3)] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
					// copy over the front and back index data
					for (int i = 0; i < indices.Length; i++) {
						allIndices[i] = indices[i] +verticesOffset; // front side uses normal indices returned from the algorithm
						allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length + verticesOffset; // backside reverses the order
					}
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1 + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0+ verticesOffset;
					allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
	}
	
	/*
	*	GetMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignFlatMesh(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
			
		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {0,1,2,0,2,3}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length * 4];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length * 4];
		
		float halfDepth = -mcd.meshDepth/2.0f;
			for (int i=0; i<vertices2D.Length; i++) {
				float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
				float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
				vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
				vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
				vertX = vertX + mcd.widthOffset;
				vertY = vertY + mcd.heightOffset;
				vertices[i] = new Vector3(vertX, vertY, -halfDepth);
				vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
				vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
				vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
				uvs[i] = frontUVs[i];
				uvs[i+vertices2D.Length] = uvs[i];
				uvs[i+(vertices2D.Length*2)] = uvs[i];
				uvs[i+(vertices2D.Length*3)] = uvs[i];
		}
			
		// make the back side triangle indices
		// double the indices for front and back, 6 times the number of edges on front
		int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
		// copy over the front and back index data
		for (int i = 0; i < indices.Length; i++) {
			allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
			allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
		}
			
		// create the side triangle indices
		// for each edge, create a new set of two triangles
		// edges are just two points from the original set
		for (int i = 0; i < vertices2D.Length - 1; i++) {
			allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
			allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
			allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
			allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
			allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
			allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
		}
			
		// wrap around for the last face
		allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
		allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
		allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
		allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
		allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
		allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
			
		msh.vertices = vertices;
		msh.triangles = allIndices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
	}
	
	/*
	*	AssignPlaneMesh() does calculation for a simple plane with uv coordinates
	* at the corners of the images. Really simple.
	*/ 
	public void AssignPlaneMesh(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
			
		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {0,1,2,0,2,3}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length];
		
		float halfDepth = -mcd.meshDepth/2.0f;
		for (int i=0; i<vertices2D.Length; i++) {
			float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
			float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
			vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
			vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
			vertX = vertX + mcd.widthOffset;
			vertY = vertY + mcd.heightOffset;
			vertices[i] = new Vector3(vertX, vertY, -halfDepth);
			uvs[i] = frontUVs[i];
		}
			
		msh.vertices = vertices;
		msh.triangles = indices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
	}
	
	/*
	*	AssignPlaneMesh() does calculation for a simple plane with uv coordinates
	* at the corners of the images. Really simple.
	*/ 
	public void AssignPlaneMeshBackside(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
			
		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		// need a list of ordered 2d points
		Vector2 [] vertices2D = {new Vector2(0.0f,0.0f), new Vector2(0.0f, imageHeight), new Vector2(imageWidth, imageHeight), new Vector2(imageWidth,0.0f)};
        
		// 
		int[] indices = {2,1,0,3,2,0}; // these will be reversed for the back side
		Vector2[] frontUVs = {new Vector2(0.0f,0.0f), new Vector2(0.0f,1.0f), new Vector2(1.0f,1.0f), new Vector2(1.0f,0.0f) };
		Vector2[] uvs = new Vector2[vertices2D.Length];
		// Create the Vector3 vertices
		Vector3[] vertices = new Vector3[vertices2D.Length];
		
		float halfDepth = mcd.meshDepth/2.0f;
		for (int i=0; i<vertices2D.Length; i++) {
			float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
			float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
			vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
			vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
			vertX = vertX + mcd.widthOffset;
			vertY = vertY + mcd.heightOffset;
			vertices[i] = new Vector3(vertX, vertY, -halfDepth);
			uvs[i] = frontUVs[i];
		}
			
		msh.vertices = vertices;
		msh.triangles = indices;
		msh.uv = uvs;
		msh.RecalculateNormals();
		msh.RecalculateBounds();
		msh.name = mcd.outlineTexture.name + ".mesh";
	}
	
	/*
	*	GetMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignEdgeMesh(ref Mesh msh) {
			string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
			TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
			textureImporter.isReadable = true;
			AssetDatabase.ImportAsset(path);
			
			//Debug.Log("found texture " + outlineTexture.width + "," + outlineTexture.height);
			Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			//Debug.Log("total pixel count " + pixels.Length);
			
			// possibly do some size checking
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
				Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
				Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
			}
			
			// make a surface object to create and store data from image
			MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			// Create the mesh
			//Mesh msh = new Mesh();
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				Triangulator tr = new Triangulator(vertices2D);
				int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 2];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 2];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = -mcd.meshDepth/2.0f;
				float halfVerticalPixel = 0.5f/imageHeight;
				float halfHorizontalPixel = 0.5f/imageWidth;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					//vertices[i] = new Vector3(vertX, vertY, -halfDepth);
					//vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
					vertices[i] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
					vertices[i +vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
					//uvs[i+(vertices2D.Length*2)] = uvs[i];
					//uvs[i+(vertices2D.Length*3)] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[vertices2D.Length  * 6];
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[ (6 * i)] = i + 1;
					allIndices[ (6 * i) + 1] =  i ;
					allIndices[ (6 * i) + 2] =   i + 1 + vertices2D.Length;
					allIndices[ (6 * i) + 3] =   i + 1 + vertices2D.Length;
					allIndices[ (6 * i) + 4] =  i ;
					allIndices[ (6 * i) + 5] = i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = 0;
				allIndices[allIndices.Length-5] = vertices2D.Length-1;
				allIndices[allIndices.Length-4] =vertices2D.Length;
				allIndices[allIndices.Length-3] = vertices2D.Length;
				allIndices[allIndices.Length-2] = vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					// TODO: this needs to check if the current list is inside another shape
					// Use the triangulator to get indices for creating triangles
					Triangulator tr = new Triangulator(vertices2D);
					int[] indices = tr.Triangulate(); // these will be reversed for the back side
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = -mcd.meshDepth/2.0f;
					float halfVerticalPixel = 0.5f/imageHeight;
					float halfHorizontalPixel = 0.5f/imageWidth;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) - halfHorizontalPixel; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight + halfVerticalPixel; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX, vertY, -halfDepth);
						vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
						//vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
						//vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
						//uvs[i+(vertices2D.Length*2)] = uvs[i];
						//uvs[i+(vertices2D.Length*3)] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[vertices2D.Length * 6];
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(6 * i)] = i + 1 + verticesOffset;
						allIndices[(6 * i) + 1] = i + verticesOffset;
						allIndices[(6 * i) + 2] =  i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[ (6 * i) + 3] =  i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(6 * i) + 4] =  i + verticesOffset;
						allIndices[(6 * i) + 5] =  i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] =  0+ verticesOffset;
					allIndices[allIndices.Length-5] =vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
	}
}

